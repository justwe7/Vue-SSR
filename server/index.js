const fs = require('fs')
const express = require('express')
const server = express()
const path = require('path')
const LRU = require('lru-cache')
// const renderer = require('vue-server-renderer').createRenderer({
//   template: require('fs').readFileSync('./index.template.html', 'utf-8')
// })
const { createBundleRenderer } = require('vue-server-renderer')
const resolve = file => path.resolve(__dirname, file)
const isProd = process.env.NODE_ENV === 'production'

const LRUCache = new LRU({
  max: 1000,
  maxAge: 1000 * 60 * 15
})
// const createApp = require('./src/app')

// function createRenderer (bundle, options) {
//   // https://github.com/vuejs/vue/blob/dev/packages/vue-server-renderer/README.md#why-use-bundlerenderer
//   return createBundleRenderer(bundle, Object.assign(options, {
//     // for component caching
//     cache: LRUCache,
//     // this is only needed when vue-server-renderer is npm-linked
//     basedir: resolve('../dist'),
//     // recommended for performance
//     runInNewContext: false
//   }))
// }

let templatePath // 渲染的html模板
let renderer // createBundleRenderer() 创建的实例
let readyPromise // 开发环境，等待服务启动的异步标识

/* 通用-用于创建 vue-server-renderer/createBundleRenderer 的实例 */
const createRenderer = (serverBundle, options) => {
  // https://github.com/vuejs/vue/blob/dev/packages/vue-server-renderer/README.md#why-use-bundlerenderer
  return createBundleRenderer(serverBundle, Object.assign(options, {
    basedir: resolve('../../dist'),
    runInNewContext: false, // 推荐
    // template: fs.readFileSync('./public/index.ssr.html', 'utf-8'), // 与require不同，fs模块取运行指令时目录的pwd
    // clientManifest // （可选）客户端构建 manifest
  }))
}
// const templatePath = resolve('../public/index.template.html')
// 生产环境使用服务端构建的包进行渲染
// if (isProd) {
//   const bundle = require('../dist/vue-ssr-server-bundle.json') // 用于服务端渲染的渲染数据
//   renderer = createBundleRenderer(bundle, {
//     runInNewContext: false,
//     template: fs.readFileSync('./public/index.template.html', 'utf-8'), // 与require不同，fs模块取运行指令时目录的pwd
//     clientManifest
//   })
// } else {
//   // 构建开发环境，本地起express服务渲染
//   // In development: setup the dev server with watch and hot-reload,
//   // and create a new renderer on bundle / index template update.
//   readyPromise = require('../build/setup-dev-server')(
//     server,
//     templatePath,
//     (bundle, options) => {
//       renderer = createRenderer(bundle, options)
//     }
//   )
// }
if (isProd) {
  templatePath = resolve('../public/index.template.html')
  const template = fs.readFileSync(templatePath, 'utf-8')
  const serverBundle = require(resolve('../dist/vue-ssr-server-bundle.json'))
  const clientManifest = require(resolve('../dist/vue-ssr-client-manifest.json'))
  // In production: create server renderer using template and built server bundle.
  // The server bundle is generated by vue-ssr-webpack-plugin.
  renderer = createRenderer(serverBundle, {
    template,
    clientManifest,
    // inject: false
  })
/* 开发 */
} else {
  templatePath = resolve('../public/index.template.html')
  const setupDevServer = require(resolve('../build/setup-dev-server'))(
    server,
    templatePath,
    (bundle, options) => {
      options.inject = false
      renderer = createRenderer(bundle, options)
    }
  )
  readyPromise = setupDevServer.readyPromise
  // devFs = setupDevServer.fs
}

/* 生成服务端渲染后的html内容string */
function renderToString(context) {
  return new Promise((resolve, reject) => {
    renderer.renderToString(context, (err, html) => {
      if (err) {
        reject(err)
        return
      }
      resolve(html)
    })
  })
}

const serve = (path, cache) =>
  express.static(resolve(path), {
    maxAge: cache ? 1000 * 60 * 60 * 24 * 30 : 0
  })

/* 定义静态目录，否则会导致所有文件都通过vue-router来查找 */
server.use('/css', express.static(resolve('../dist/css')))
server.use('/js', express.static(resolve('../dist/js')))


async function renderHtml(req, res) {
  const context = {
    url: req.url,
    title: '上下文title',
    tag: `<div>SSR插入的标签</div>`
  }

  try {
    // console.log(context)
    const html = await renderToString(context)
    res.send(html)
  } catch (error) {
    console.log(error)
    res.status(500).end('Internal Server Error')
  }
}

server.get('*', isProd ? renderHtml : (req, res) => {
  readyPromise.then(() => renderHtml(req, res))
})

server.listen(3000)
